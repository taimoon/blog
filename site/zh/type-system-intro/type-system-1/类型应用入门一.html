<html lang="zh">
  <head>
    <meta date="2024-10-30"/>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width" initial-scale="1.0"/>
    <link rel="stylesheet" href="/style.css"/>
    <title>类型应用入门一</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css"/>
    <script id="ajax-highlight" defer="" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
              document.addEventListener('DOMContentLoaded', function() {
                    var element = document.getElementById('ajax-highlight');
                    if (element) {
                        hljs.highlightAll();
                    }
                });
             </script>
    <script id="MathJax-script-forreal" defer="" src="https://cdn.mathjax.org/mathjax/2.7-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
        inlineMath: [ ['$','$'] ],
        processEscapes: true
        }
    });
    </script>
  </head>
  <header>
    <nav>
      <ul>
        <li>
          <a href="/zh/index.html">home</a>
        </li>
        <li>
          <a href="/zh/about/关于.html">about</a>
        </li>
        <li>
          <a href="/en/type-system-intro/type-system-1/type-system-1.html">English</a>
        </li>
      </ul>
    </nav>
  </header>
  <main><p>date: 2024-10-30</p><h1>类型应用入门一</h1>
<h1>求json的类型</h1>
<pre><code class="language-json">3
</code></pre>
<p>number (either integer or float)</p>
<pre><code class="language-json">true
</code></pre>
<p>boolean</p>
<pre><code class="language-json">'patchouli'
</code></pre>
<p>string</p>
<pre><code class="language-json">null
</code></pre>
<p>null</p>
<pre><code class="language-json">[11,13,17]
</code></pre>
<p>array</p>
<pre><code>{
    '甲' : 1,
    '乙' : 2,
    '丙' : 3
}
</code></pre>
<p>javascript object (or named-value pair, dictionary, map)</p>
<p>至少有六个可以是描述json的类型。我们可以使用<code>Union</code>(联合)来描述多个类型。<code>python</code>的写法是</p>
<pre><code class="language-py">json_ty = int|float|bool|None|str|list|dict
</code></pre>
<h1>Options</h1>
<p>有些函数实现可以要么返回空值以表示没有，要么是结果。可以描述其类型为<code>T|None</code></p>
<p>例子,</p>
<pre><code class="language-py">def copy_file(input_path: str, output_path: str|None = None) -&gt; None:
    '''
    Example Usage
    ---
    ```
    copy_file('foo.txt', 'bar.txt')
    copy_file('foo.txt') ==&gt; copy_file('foo.txt','foo_copy.txt')
    ```
    '''
    import os
    if output_path is None:
        wkdir, file_name = os.path.split(input_path)
        file_stem, file_ext = os.path.splitext(file_name)
        output_path = os.path.join(wkdir, file_stem + '_copy' + file_ext)

    with open(input_path, 'rb') as inp:
        with open(output_path, 'wb+') as out:
            out.write(inp.read())
</code></pre>
<p>因为太常用，<code>python</code>也提供<code>Optional</code>的写法</p>
<pre><code class="language-py">from typing import Optional
def copy_file(input_path: str, output_path: Optional[str] = None) -&gt; None:
    '''
    Example Usage
    ---
    ```
    copy_file('foo.txt', 'bar.txt')
    copy_file('foo.txt') ==&gt; copy_file('foo.txt','foo_copy.txt')
    ```
    '''
    import os
    if output_path is None:
        wkdir, file_name = os.path.split(input_path)
        file_stem, file_ext = os.path.splitext(file_name)
        output_path = os.path.join(wkdir, file_stem + '_copy' + file_ext)

    with open(input_path, 'rb') as inp:
        with open(output_path, 'wb+') as out:
            out.write(inp.read())
</code></pre>
<h1>多态</h1>
<pre><code class="language-py">def max(x: int|float, y: int|float) -&gt; int|float:
    if x &lt; y:
        return y
    else:
        return x
</code></pre>
<p>以上<code>max</code>函数会比较两个数，返还较大的数。
<code>max</code>函数实现可以支持不同类型的参数比如整数，分数，实数。
当我们尝试让程序接受不同类型，这程序是多态的。</p>
<p>好几种方式可以让程序达到多态</p>
<ul>
<li>子类多态 (例: 继承)</li>
<li>参数多态 (例: 泛型)</li>
<li>函数分派 (例: Julia dynamic dispatch, C++ overload resolution)</li>
<li>鸭子类型 (例: Python, <del>那么可爱肯定是男孩子</del>)</li>
<li>变体类型</li>
</ul>
<h1>进阶：泛型</h1>
<pre><code class="language-py">from typing import Callable
def compose(f: Callable[[int], int], g: Callable[[int], int]) -&gt; Callable[[int], int]:
    def wrapped(x: int) -&gt; int:
        return f(g(x))
    return wrapped

def sqr(x: int) -&gt; int:
    return x * x

f = compose(sqr,sqr)
print(f(2)) # 16
</code></pre>
<p>如上，我们实现<code>compose</code>可以复合两个函数成一个函数（如同复合函数）。
以上<code>compose</code>只给整数函数定义，但<code>compose</code>应该是通用，接受其他类型比如</p>
<pre><code class="language-py">str.strip   : ((str) -&gt; str)
str.__len__ : ((str) -&gt; int)
---
compose(str.strip, str.__len__) : ((str) -&gt; int)

sqr : ((int) -&gt; int)
---
compose(compose(str.strip, str.len),str.__len__) : ((str) -&gt; int)
</code></pre>
<p>为了可以描述这种通用性，我们可以引入泛型的概念，如同以类型代入变量那样。在python3.12之后，可以这么写。</p>
<pre><code class="language-py">from typing import Callable
def identity[X](x: X) -&gt; X:
    return x

def compose[X, Y, Z](f: Callable[[X], Y], g: Callable[[Y], Z]) -&gt; Callable[[X], Z]:
    def wrapped(x: X) -&gt; Z:
        return f(g(x))
    return wrapped


def sqr(x: int) -&gt; int:
    return x * x

x: int = identity(10)
y: str = identity('s')
f: Callable[[int], int] = compose(sqr,sqr)
g: Callable[[str], int] = compose(str.strip, str.__len__)
h: Callable[[str], int] = compose(compose(str.strip, str.__len__),sqr)
H: Callable[[str], int] = compose(compose(str.strip, str.__len__),compose(sqr,identity))
</code></pre>
<h1>进阶：递归类型</h1>
<p>刚才json的类型描述还是不够精确。
javascript object是一种关联表，键类型必须是string但是值可以任何json类型。 
数组的元素可以是任何json类型。比如</p>
<pre><code class="language-json">{
    'jan' : 1,
    'feb' : 2,
    'mac' : '三月',
    'foo' : false,
    'bar' : null,
    '哦，卖糕的' : {
        '甲' : 1,
        '乙' : 2,
        '丙' : 3
        },
    'basic' : [1,true,false,null]
}
</code></pre>
<p>在<code>python</code>里，可以写成</p>
<pre><code class="language-py">type json_ty = None|bool|int|float|str|list[json_ty]|dict[str,json_ty]
</code></pre>
<p><a href="https://ocaml.org/docs/basic-data-types#recursive-variants">https://ocaml.org/docs/basic-data-types#recursive-variants</a></p>
<p><code>ocaml</code>教程写法</p>
<pre><code>type json =
  | Null
  | Bool of bool
  | Int of int
  | Float of float
  | String of string
  | Array of json list
  | Object of (string * json) list;;
</code></pre>
<h1>外传：关于继承也是一种代数数据类型</h1>
<blockquote>
<p>The First Bit of Advice </p>
<p>When specifying a collection of data, 
use abstract classes for data types and 
extended classes for variants. </p>
</blockquote>
<p>摘之The Little Java: Few Patterns</p>
<p>比如以下是<code>haskell</code>风格的ADT写法</p>
<pre><code class="language-haskell">data Peano = Zero | Succ Peano

Succ (Succ (Succ Zero)) :: Peano
</code></pre>
<p>在<code>java</code>, 可以写成：</p>
<pre><code class="language-java">abstract class Peano {}
...
class Zero extends Num {}
...
class Succ extends Num {}
...
Succ(Succ(Zero)) // also an instance of Peano number
</code></pre>
<h1>后日谈</h1>
<p>写这笔记的时候，发现python已经糖化泛型的写法。可恶，竟然在我眼皮子底下偷偷加入的。</p></main>
  <footer>
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">COPYRIGHT NOTICE: CC BY-SA 4.0</a>
    <a href="https://github.com/taimoon">github</a>
  </footer>
</html>
